<!DOCTYPE html>
<html lang="sl">
<head>
  <meta charset="UTF-8" />
  <link rel="icon" href="/favicon.ico" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="manifest" href="manifest.json" />
  <meta name="theme-color" content="#3f51b5" />
  <title>PWA Task Manager</title>
  <link rel="stylesheet" href="styles.css" />
  <style>
    /* Basic style for lazy loaded images */
    img.lazy {
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
    }
    img.lazy.loaded {
      opacity: 1;
    }
  </style>
</head>
<body>
  <header>
    <h1>Task Manager</h1>
    <div>
      <button id="mode-toggle">🌙 Preklopi temni način</button>
      <button id="logout-btn">Odjava</button>
    </div>
  </header>

  <!-- Local image inserted between header and API data section -->
  <div style="text-align: center; margin: 2rem 0;">
    <h3>Nalagam lokalno sliko:</h3>
    <img class="lazy" data-src="/images/image.png" alt="Lokalna slika" width="600" height="400" />
  </div>

  <h2>Prikaži podatke iz API-ja</h2>
  <div id="data-controls">
    <select id="entity-selector">
      <option value="tasks">Opravila</option>
      <option value="achievements" selected>Dosežki</option>
      <option value="calendar_entries">Koledarski vnosi</option>
      <option value="progress_logs">Dnevnik napredka</option>
      <option value="user_settings">Nastavitve uporabnika</option>
      <option value="user_profiles">Uporabniški profili</option>
      <option value="users">Uporabniki</option>
    </select>

    <select id="view-mode">
      <option value="list">Seznam</option>
      <option value="card">Kartice</option>
      <option value="table">Tabela</option>
    </select>

    <button id="load-entity">Naloži podatke</button>
  </div>

  <div id="search-controls" style="display: flex; align-items: center; gap: 0.5rem; margin-top: 0.5rem;">
    <input type="text" id="search-id" placeholder="Išči po ID-ju" style="width: 300px;" />
    <button id="search-by-id">Išči</button>
    <button id="add-entry">Dodaj vnos</button>
  </div>

  <div id="achievementsContainer"></div>

  <div id="api-data"></div>

  <div id="edit-modal" class="modal hidden">
    <div class="modal-content">
      <h3 id="modal-title">Uredi vnos</h3>
      <form id="edit-form"></form>
      <div class="modal-actions">
        <button type="submit" form="edit-form">Shrani</button>
        <button type="button" id="cancel-edit">Prekliči</button>
      </div>
    </div>
  </div>

  <script>
    const token = localStorage.getItem('accessToken');
    if (!token) window.location.href = '/login.html';

    function showNotification(message) {
      if ('Notification' in window && Notification.permission === 'granted') {
        new Notification(message);
      } else {
        alert(message);
      }
    }

    const apiData = document.getElementById('api-data');
    const viewModeSelect = document.getElementById('view-mode');
    const deletableEntities = [
      'tasks', 'achievements', 'calendar_entries',
      'progress_logs', 'user_settings', 'user_profiles', 'users'
    ];
    const editableEntities = [...deletableEntities];

    const DB_NAME = 'achievementsDB';
    const DB_VERSION = 1;
    const ACHIEVEMENTS_STORE = 'achievements';
    const UNSYNCED_STORE = 'unsyncedAchievements';

    function openDatabase() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = (event) => {
          console.error("IndexedDB napaka:", event.target.error);
          reject(event.target.error);
        };
        request.onsuccess = () => {
          resolve(request.result);
        };
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(ACHIEVEMENTS_STORE)) {
            db.createObjectStore(ACHIEVEMENTS_STORE, { keyPath: 'id', autoIncrement: true });
          }
          if (!db.objectStoreNames.contains(UNSYNCED_STORE)) {
            db.createObjectStore(UNSYNCED_STORE, { keyPath: 'localId', autoIncrement: true });
          }
        };
      });
    }

    function saveAchievementsDB(achievements) {
      return openDatabase().then(db => {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction(ACHIEVEMENTS_STORE, "readwrite");
          const store = transaction.objectStore(ACHIEVEMENTS_STORE);
          const clearRequest = store.clear();
          clearRequest.onerror = () => reject(clearRequest.error);
          clearRequest.onsuccess = () => {
            achievements.forEach(item => store.put(item));
            transaction.oncomplete = () => resolve();
            transaction.onerror = () => reject(transaction.error);
          };
        });
      });
    }

    function getAchievementsDB() {
      return openDatabase().then(db => {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction(ACHIEVEMENTS_STORE, "readonly");
          const store = transaction.objectStore(ACHIEVEMENTS_STORE);
          const request = store.getAll();
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result);
        });
      });
    }

    function addUnsyncedAchievementDB(achievement) {
      return openDatabase().then(db => {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction(UNSYNCED_STORE, "readwrite");
          const store = transaction.objectStore(UNSYNCED_STORE);
          const request = store.add(achievement);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result);
        });
      });
    }

    function getUnsyncedAchievementsDB() {
      return openDatabase().then(db => {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction(UNSYNCED_STORE, "readonly");
          const store = transaction.objectStore(UNSYNCED_STORE);
          const request = store.getAll();
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result);
        });
      });
    }

    function deleteUnsyncedAchievementDB(localId) {
      return openDatabase().then(db => {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction(UNSYNCED_STORE, "readwrite");
          const store = transaction.objectStore(UNSYNCED_STORE);
          const request = store.delete(localId);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve();
        });
      });
    }

    function fetchAchievements() {
      console.log("fetchAchievements() se izvaja.");
      fetch("/api/achievements", { headers: { Authorization: `Bearer ${token}` } })
        .then(response => response.json())
        .then(data => {
          console.log("Dosežki, prejeta iz API-ja:", data);
          saveAchievementsDB(data)
            .then(() => console.log("Dosežki shranjeni v IndexedDB."))
            .catch(err => console.error("Napaka pri shranjevanju v IndexedDB:", err));
          updateUI(data);
        })
        .catch(error => {
          console.error("Napaka pri pridobivanju dosežkov s strežnika, uporaba IndexedDB:", error);
          getAchievementsDB()
            .then(localData => { updateUI(localData); })
            .catch(err => console.error("Napaka pri branju iz IndexedDB:", err));
        });
    }

    function createAchievement(achievementData) {
      console.log("Ustvarjam dosežek:", achievementData);
      if (navigator.onLine) {
        fetch("/api/achievements", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`
          },
          body: JSON.stringify(achievementData)
        })
          .then(response => response.json())
          .then(newAchievement => {
            console.log("Dosežek uspešno ustvarjen online:", newAchievement);
            newAchievement.synced = true;
            getAchievementsDB()
              .then(existing => {
                const updated = existing.concat(newAchievement);
                saveAchievementsDB(updated)
                  .then(() => updateUI(updated))
                  .catch(err => console.error("Napaka pri shranjevanju dosežkov:", err));
              });
          })
          .catch(error => {
            console.error("Napaka pri ustvarjanju dosežka online:", error);
          });
      } else {
        achievementData.synced = false;
        addUnsyncedAchievementDB(achievementData)
          .then(localId => {
            console.log("Dosežek shranjen offline z localId:", localId);
            getAchievementsDB()
              .then(existing => {
                const updated = existing.concat(achievementData);
                saveAchievementsDB(updated)
                  .then(() => updateUI(updated))
                  .catch(err => console.error("Napaka pri shranjevanju dosežkov:", err));
              });
          })
          .catch(err => console.error("Napaka pri shranjevanju nesinhroniziranega dosežka:", err));
      }
    }

    function syncAchievements() {
      getUnsyncedAchievementsDB()
        .then(unsynced => {
          if (unsynced.length > 0) {
            console.log(`Sinhroniziram ${unsynced.length} dosežkov, ki niso sinhronizirani...`);
            unsynced.forEach(achievement => {
              fetch("/api/achievements", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  Authorization: `Bearer ${token}`
                },
                body: JSON.stringify(achievement)
              })
                .then(response => response.json())
                .then(newAchievement => {
                  console.log("Dosežek sinhroniziran:", newAchievement);
                  deleteUnsyncedAchievementDB(achievement.localId)
                    .then(() => {
                      getAchievementsDB()
                        .then(existing => {
                          const updated = existing.concat(newAchievement);
                          saveAchievementsDB(updated)
                            .then(() => updateUI(updated))
                            .catch(err => console.error("Napaka pri posodabljanju dosežkov:", err));
                        })
                        .catch(err => console.error("Napaka pri branju dosežkov:", err));
                    })
                    .catch(err => console.error("Napaka pri brisanju nesinhroniziranega dosežka:", err));
                })
                .catch(error => {
                  console.error("Sinhronizacija ni uspela za dosežek:", achievement, error);
                });
            });
          }
        })
        .catch(err => console.error("Napaka pri branju nesinhroniziranih dosežkov:", err));
    }

    window.addEventListener("online", () => {
      console.log("Povezava je vzpostavljena. Sinhroniziram offline podatke...");
      syncAchievements();
    });

    function updateUI(achievements) {
      const container = document.getElementById("achievementsContainer");
      if (!container) return;
      container.innerHTML = "";
      achievements.forEach(achievement => {
        const div = document.createElement("div");
        div.textContent = achievement.title || JSON.stringify(achievement);
        container.appendChild(div);
      });
    }

    document.getElementById('load-entity').addEventListener('click', async () => {
      const entity = document.getElementById('entity-selector').value;
      if (entity === "achievements") {
        fetchAchievements();
      } else {
        try {
          const res = await fetch(`/api/${entity}`, { headers: { Authorization: `Bearer ${token}` } });
          if (res.status === 401) {
            window.location.href = '/login.html';
            return;
          }
          const data = await res.json();
          renderData(data, entity);
        } catch (error) {
          console.error('Napaka pri nalaganju podatkov:', error);
          showNotification('Prišlo je do napake pri nalaganju podatkov.');
        }
      }
    });

    viewModeSelect.addEventListener('change', () => {
      document.getElementById('load-entity').click();
    });

    function formatDate(value) {
      const date = new Date(value);
      return !isNaN(date)
        ? date.toLocaleString('en-US', {
            year: 'numeric',
            month: 'long',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            hour12: true
          })
        : value;
    }

    function renderData(data, entity) {
      const mode = viewModeSelect.value;
      apiData.innerHTML = '';
      if (!Array.isArray(data) || data.length === 0) {
        apiData.textContent = 'Ni podatkov za prikaz.';
        return;
      }
      if (mode === 'list') {
        const pre = document.createElement('pre');
        pre.textContent = JSON.stringify(data, null, 2);
        pre.classList.add('data-list');
        apiData.appendChild(pre);
      } else if (mode === 'card') {
        data.forEach(item => {
          const div = document.createElement('div');
          div.classList.add('data-card');
          for (const [key, value] of Object.entries(item)) {
            const p = document.createElement('p');
            const isDateField = ['date', 'timestamp', 'created_at', 'updated_at'].some(sub =>
              key.toLowerCase().includes(sub)
            );
            const formattedValue = isDateField ? formatDate(value) : value;
            p.innerHTML = `<strong>${key}:</strong> ${formattedValue}`;
            div.appendChild(p);
          }
          if (editableEntities.includes(entity)) {
            const editBtn = document.createElement('button');
            editBtn.textContent = 'Uredi';
            editBtn.classList.add('edit-btn');
            editBtn.onclick = () => showEditModal(entity, item);
            div.appendChild(editBtn);
          }
          if (deletableEntities.includes(entity)) {
            const delBtn = document.createElement('button');
            delBtn.textContent = 'Izbriši';
            delBtn.classList.add('delete-btn');
            delBtn.onclick = () => deleteItem(entity, item.id);
            div.appendChild(delBtn);
          }
          apiData.appendChild(div);
        });
      } else if (mode === 'table') {
        const table = document.createElement('table');
        const thead = table.createTHead();
        const headerRow = thead.insertRow();
        const keys = Object.keys(data[0]);
        keys.forEach(key => {
          const th = document.createElement('th');
          th.textContent = key;
          headerRow.appendChild(th);
        });
        if (editableEntities.includes(entity)) {
          const th = document.createElement('th');
          th.textContent = 'Akcije';
          headerRow.appendChild(th);
        }
        const tbody = table.createTBody();
        data.forEach(item => {
          const row = tbody.insertRow();
          keys.forEach(key => {
            const td = row.insertCell();
            const isDateField = ['date', 'timestamp', 'created_at', 'updated_at'].some(sub =>
              key.toLowerCase().includes(sub)
            );
            td.textContent = isDateField ? formatDate(item[key]) : item[key];
          });
          if (editableEntities.includes(entity)) {
            const td = row.insertCell();
            const editBtn = document.createElement('button');
            editBtn.textContent = 'Uredi';
            editBtn.classList.add('edit-btn');
            editBtn.onclick = () => showEditModal(entity, item);
            td.appendChild(editBtn);
            const delBtn = document.createElement('button');
            delBtn.textContent = 'Izbriši';
            delBtn.classList.add('delete-btn');
            delBtn.onclick = () => deleteItem(entity, item.id);
            td.appendChild(delBtn);
          }
        });
        const wrapper = document.createElement('div');
        wrapper.classList.add('data-table');
        wrapper.appendChild(table);
        apiData.appendChild(wrapper);
      }
    }

    async function deleteItem(entity, id) {
      if (!confirm('Ali ste prepričani, da želite izbrisati ta vnos?')) return;
      try {
        const res = await fetch(`/api/${entity}/${id}`, {
          method: 'DELETE',
          headers: { Authorization: `Bearer ${token}` }
        });
        if (res.ok) {
          showNotification('Vnos uspešno izbrisan.');
          document.getElementById('load-entity').click();
        } else {
          showNotification('Brisanje vnosa ni uspelo.');
        }
      } catch (error) {
        console.error('Napaka pri brisanju:', error);
        showNotification('Med brisanjem je prišlo do napake.');
      }
    }

    function showEditModal(entity, item) {
      const modal = document.getElementById('edit-modal');
      const form = document.getElementById('edit-form');
      document.getElementById('modal-title').textContent = 'Uredi vnos';
      form.innerHTML = '';
      modal.classList.remove('hidden');
      for (const [key, value] of Object.entries(item)) {
        if (key === 'id') continue;
        const input = document.createElement('input');
        input.name = key;
        input.placeholder = key;
        input.required = true;
        if (typeof value === 'number') {
          input.type = 'number';
          input.value = value;
        } else if (key.toLowerCase().includes('date') || key.toLowerCase().includes('timestamp')) {
          input.type = 'datetime-local';
          const date = new Date(value);
          if (!isNaN(date)) {
            const local = new Date(date.getTime() - date.getTimezoneOffset() * 60000);
            input.value = local.toISOString().slice(0, 16);
          }
        } else {
          input.type = 'text';
          input.value = value;
        }
        form.appendChild(input);
      }
      form.onsubmit = async (e) => {
        e.preventDefault();
        const formData = new FormData(form);
        const data = {};
        for (const [key, value] of formData.entries()) {
          if (value === '') continue;
          if (key.toLowerCase().includes('date') || key.toLowerCase().includes('timestamp')) {
            const date = new Date(value);
            if (!isNaN(date)) {
              data[key] = date.toISOString().slice(0, 19).replace('T', ' ');
            }
          } else {
            data[key] = value;
          }
        }
        try {
          const res = await fetch(`/api/${entity}/${item.id}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
              Authorization: `Bearer ${token}`
            },
            body: JSON.stringify(data)
          });
          if (res.ok) {
            showNotification('Vnos uspešno posodobljen!');
            modal.classList.add('hidden');
            document.getElementById('load-entity').click();
          } else {
            const error = await res.json();
            showNotification(`Posodobitev ni uspela: ${error.message || res.status}`);
          }
        } catch (err) {
          showNotification('Med posodabljanjem je prišlo do napake.');
          console.error(err);
        }
      };
    }

    function showAddModal(entity, template) {
      const modal = document.getElementById('edit-modal');
      const form = document.getElementById('edit-form');
      document.getElementById('modal-title').textContent = 'Dodaj nov vnos';
      form.innerHTML = '';
      modal.classList.remove('hidden');
      if (template && Object.keys(template).length > 0) {
        for (const key of Object.keys(template)) {
          if (key === 'id') continue;
          const input = document.createElement('input');
          input.name = key;
          input.placeholder = key;
          input.required = true;
          if (typeof template[key] === 'number') {
            input.type = 'number';
          } else if (key.toLowerCase().includes('date') || key.toLowerCase().includes('timestamp')) {
            input.type = 'datetime-local';
          } else {
            input.type = 'text';
          }
          input.value = '';
          form.appendChild(input);
        }
      } else {
        const textarea = document.createElement('textarea');
        textarea.name = 'json';
        textarea.placeholder = 'Vnesite JSON podatke za nov vnos';
        textarea.required = true;
        textarea.style.width = '100%';
        textarea.style.height = '200px';
        form.appendChild(textarea);
      }
      form.onsubmit = async (e) => {
        e.preventDefault();
        let data;
        if (template && Object.keys(template).length > 0) {
          const formData = new FormData(form);
          data = {};
          for (const [key, value] of formData.entries()) {
            if (value === '') continue;
            if (key.toLowerCase().includes('date') || key.toLowerCase().includes('timestamp')) {
              const date = new Date(value);
              if (!isNaN(date)) {
                data[key] = date.toISOString().slice(0, 19).replace('T', ' ');
              }
            } else {
              if (template[key] !== undefined && typeof template[key] === 'number') {
                data[key] = Number(value);
              } else {
                data[key] = value;
              }
            }
          }
        } else {
          const jsonVal = form.elements['json'].value;
          try {
            data = JSON.parse(jsonVal);
          } catch (err) {
            showNotification('Neveljaven JSON.');
            return;
          }
        }
        try {
          const res = await fetch(`/api/${entity}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              Authorization: `Bearer ${token}`
            },
            body: JSON.stringify(data)
          });
          if (res.ok) {
            showNotification('Nov vnos je bil uspešno ustvarjen!');
            modal.classList.add('hidden');
            document.getElementById('load-entity').click();
          } else {
            const error = await res.json();
            showNotification(`Ustvarjanje ni uspelo: ${error.message || res.status}`);
          }
        } catch (err) {
          showNotification('Med ustvarjanjem je prišlo do napake.');
          console.error(err);
        }
      };
    }

    document.getElementById('cancel-edit').addEventListener('click', () => {
      document.getElementById('edit-modal').classList.add('hidden');
    });

    document.getElementById('mode-toggle').addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
    });

    document.getElementById('logout-btn').addEventListener('click', () => {
      localStorage.removeItem('accessToken');
      localStorage.removeItem('refreshToken');
      window.location.href = '/login.html';
    });

    if ('Notification' in window && Notification.permission !== 'granted') {
      Notification.requestPermission();
    }

    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('serviceWorker.js')
        .then(async reg => {
          console.log('[Main] ServiceWorker uspešno registriran.');
          const subscription = await reg.pushManager.subscribe({
            userVisibleOnly: true,
            applicationServerKey: urlBase64ToUint8Array(
              'BGtv18Gw9xNHYtH_R36gfbPG-jIKT2pHAUsTGKvg8sRBO6BfGqBjo30OBss26Lv4DtJBcmUXbCglwpf8gg55a_k'
            )
          });
          await fetch('/subscribe', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(subscription)
          });
        })
        .catch(err => console.error('[Main] Registracija ServiceWorkerja ni uspela:', err));
      
      function urlBase64ToUint8Array(base64String) {
        const padding = '='.repeat((4 - base64String.length % 4) % 4);
        const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
        const rawData = atob(base64);
        return Uint8Array.from([...rawData].map(c => c.charCodeAt(0)));
      }
    }

    document.getElementById('search-by-id').addEventListener('click', async () => {
      const entity = document.getElementById('entity-selector').value;
      const searchId = document.getElementById('search-id').value.trim();
      if (!searchId) {
        showNotification("Prosim vnesite ID za iskanje.");
        return;
      }
      try {
        const res = await fetch(`/api/${entity}/${searchId}`, {
          headers: { Authorization: `Bearer ${token}` }
        });
        if (res.status === 401) {
          window.location.href = '/login.html';
          return;
        }
        if (res.status === 404) {
          showNotification('Vnos ni bil najden.');
          return;
        }
        const data = await res.json();
        const resultData = Array.isArray(data) ? data : [data];
        renderData(resultData, entity);
      } catch (error) {
        console.error('Napaka pri iskanju:', error);
        showNotification('Med iskanjem je prišlo do napake.');
      }
    });

    document.getElementById('add-entry').addEventListener('click', async () => {
      const entity = document.getElementById('entity-selector').value;
      let template = {};
      try {
        const res = await fetch(`/api/${entity}`, {
          headers: { Authorization: `Bearer ${token}` }
        });
        if (res.ok) {
          const data = await res.json();
          if (Array.isArray(data) && data.length > 0) {
            template = data[0];
          }
        }
      } catch (e) {
        console.error(e);
      }
      showAddModal(entity, template);
    });

    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'l') {
        e.preventDefault();
        document.getElementById('load-entity').click();
      }
      if (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'a') {
        e.preventDefault();
        document.getElementById('add-entry').click();
      }
    });

    window.addEventListener("load", () => {
      if (document.getElementById('entity-selector').value === "achievements") {
        fetchAchievements();
      }
      initLazyLoading();
    });

    function initLazyLoading() {
      const lazyImages = document.querySelectorAll('img.lazy');
      console.log('[LazyLoad] Found', lazyImages.length, 'lazy images');
    
      if ('IntersectionObserver' in window) {
        const imageObserver = new IntersectionObserver((entries, observer) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              const img = entry.target;
              const src = img.dataset.src;
              console.log('[LazyLoad] Loading image:', src);
              if (src) {
                img.src = src;
                img.addEventListener('load', () => {
                  img.classList.add('loaded');
                  console.log('[LazyLoad] Image loaded:', src);
                });
                img.addEventListener('error', () => {
                  img.src = 'https://via.placeholder.com/600x400?text=Napaka+pri+sliki';
                  img.classList.add('loaded');
                  console.warn('[LazyLoad] Failed to load:', src);
                });
                observer.unobserve(img);
              }
            }
          });
        });
    
        lazyImages.forEach(img => {
          imageObserver.observe(img);
        });
      } else {
        console.warn('[LazyLoad] IntersectionObserver not supported. Loading all images.');
        lazyImages.forEach(img => {
          const src = img.dataset.src;
          if (src) {
            img.src = src;
            img.classList.add('loaded');
          }
        });
      }
    }
    
    function renderData(data, entity) {
      const mode = viewModeSelect.value;
      apiData.innerHTML = '';
      if (!Array.isArray(data) || data.length === 0) {
        apiData.textContent = 'Ni podatkov za prikaz.';
        return;
      }
      if (mode === 'list') {
        const pre = document.createElement('pre');
        pre.textContent = JSON.stringify(data, null, 2);
        pre.classList.add('data-list');
        apiData.appendChild(pre);
      } else if (mode === 'card') {
        data.forEach(item => {
          const div = document.createElement('div');
          div.classList.add('data-card');
          for (const [key, value] of Object.entries(item)) {
            const p = document.createElement('p');
            const isDateField = ['date', 'timestamp', 'created_at', 'updated_at'].some(sub =>
              key.toLowerCase().includes(sub)
            );
            const formattedValue = isDateField ? formatDate(value) : value;
            p.innerHTML = `<strong>${key}:</strong> ${formattedValue}`;
            div.appendChild(p);
          }
          if (editableEntities.includes(entity)) {
            const editBtn = document.createElement('button');
            editBtn.textContent = 'Uredi';
            editBtn.classList.add('edit-btn');
            editBtn.onclick = () => showEditModal(entity, item);
            div.appendChild(editBtn);
          }
          if (deletableEntities.includes(entity)) {
            const delBtn = document.createElement('button');
            delBtn.textContent = 'Izbriši';
            delBtn.classList.add('delete-btn');
            delBtn.onclick = () => deleteItem(entity, item.id);
            div.appendChild(delBtn);
          }
          apiData.appendChild(div);
        });
      } else if (mode === 'table') {
        const table = document.createElement('table');
        const thead = table.createTHead();
        const headerRow = thead.insertRow();
        const keys = Object.keys(data[0]);
        keys.forEach(key => {
          const th = document.createElement('th');
          th.textContent = key;
          headerRow.appendChild(th);
        });
        if (editableEntities.includes(entity)) {
          const th = document.createElement('th');
          th.textContent = 'Akcije';
          headerRow.appendChild(th);
        }
        const tbody = table.createTBody();
        data.forEach(item => {
          const row = tbody.insertRow();
          keys.forEach(key => {
            const td = row.insertCell();
            const isDateField = ['date', 'timestamp', 'created_at', 'updated_at'].some(sub =>
              key.toLowerCase().includes(sub)
            );
            td.textContent = isDateField ? formatDate(item[key]) : item[key];
          });
          if (editableEntities.includes(entity)) {
            const td = row.insertCell();
            const editBtn = document.createElement('button');
            editBtn.textContent = 'Uredi';
            editBtn.classList.add('edit-btn');
            editBtn.onclick = () => showEditModal(entity, item);
            td.appendChild(editBtn);
            const delBtn = document.createElement('button');
            delBtn.textContent = 'Izbriši';
            delBtn.classList.add('delete-btn');
            delBtn.onclick = () => deleteItem(entity, item.id);
            td.appendChild(delBtn);
          }
        });
        const wrapper = document.createElement('div');
        wrapper.classList.add('data-table');
        wrapper.appendChild(table);
        apiData.appendChild(wrapper);
      }
    }

    async function deleteItem(entity, id) {
      if (!confirm('Ali ste prepričani, da želite izbrisati ta vnos?')) return;
      try {
        const res = await fetch(`/api/${entity}/${id}`, {
          method: 'DELETE',
          headers: { Authorization: `Bearer ${token}` }
        });
        if (res.ok) {
          showNotification('Vnos uspešno izbrisan.');
          document.getElementById('load-entity').click();
        } else {
          showNotification('Brisanje vnosa ni uspelo.');
        }
      } catch (error) {
        console.error('Napaka pri brisanju:', error);
        showNotification('Med brisanjem je prišlo do napake.');
      }
    }
  </script>
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const fallbackImage = 'https://via.placeholder.com/600x400?text=Slika+ni+na+voljo';
      document.querySelectorAll('img.lazy').forEach(img => {
        img.addEventListener('error', () => {
          img.src = fallbackImage;
          img.classList.add('loaded');
        });
      });
    });
  </script>  
</body>
</html>